{"version":3,"file":"abort-controller.umd.js.map","sources":["../node_modules/event-target-shim/dist/event-target-shim.mjs","../src/abort-signal.mjs","../src/abort-controller.mjs"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2017 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        const data = pd(this);\n        if (data.passiveListener != null) {\n            console.warn(\"Event#preventDefault() was called from a passive listener:\", data.passiveListener);\n            return\n        }\n        if (!data.event.cancelable) {\n            return\n        }\n\n        data.canceled = true;\n        if (typeof data.event.preventDefault === \"function\") {\n            data.event.preventDefault();\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", { value: Event, configurable: true, writable: true });\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = (typeof descriptor.value === \"function\");\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the stopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).stopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\")\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    }\n                    else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    }\n                    else {\n                        listeners.delete(eventName);\n                    }\n                }\n                else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                }\n                else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: { value: CustomEventTarget, configurable: true, writable: true },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n * \n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n * \n * For example:\n * \n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {boolean} `true` if the listener was added actually.\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return false\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = (capture ? CAPTURE : BUBBLE);\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return true\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return false\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n        return true\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {boolean} `true` if the listener was removed actually.\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return false\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = (capture ? CAPTURE : BUBBLE);\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                }\n                else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                }\n                else {\n                    listeners.delete(eventName);\n                }\n                return true\n            }\n\n            prev = node;\n            node = node.next;\n        }\n\n        return false\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError(\"\\\"event.type\\\" should be a string.\")\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                }\n                else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                }\n                else {\n                    listeners.delete(eventName);\n                }\n            }\n            else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null));\n            if (typeof node.listener === \"function\") {\n                node.listener.call(this, wrappedEvent);\n            }\n            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", { value: EventTarget, configurable: true, writable: true });\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };\n//# sourceMappingURL=event-target-shim.mjs.map\n","import { EventTarget, defineEventAttribute } from \"event-target-shim\"\n\n/**\n * Aborted flag for each instances.\n * @type {WeakMap<AbortSignal, boolean>}\n */\nconst abortedFlags = new WeakMap()\n\n/**\n * The signal class.\n * @constructor\n * @name AbortSignal\n * @see https://dom.spec.whatwg.org/#abortsignal\n */\nexport default class AbortSignal extends EventTarget {\n    constructor() {\n        throw new TypeError(\"AbortSignal cannot be constructed directly\")\n        // Appease Rollup\n        super()\n    }\n\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     * @property\n     * @memberof AbortSignal\n     * @name aborted\n     * @type {boolean}\n     */\n    get aborted() {\n        const aborted = abortedFlags.get(this)\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`)\n        }\n        return Boolean(aborted)\n    }\n\n    /**\n     * The event attribute for `abort` event.\n     * @property\n     * @memberof AbortSignal\n     * @name onabort\n     * @type {Function}\n     */\n}\n\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: {\n        enumerable: true,\n    },\n})\n\ndefineEventAttribute(AbortSignal.prototype, \"abort\")\n\n/**\n * Create an AbortSignal object.\n * @returns {AbortSignal}\n */\nexport function createAbortSignal() {\n    const signal = Object.create(AbortSignal.prototype)\n    EventTarget.call(signal)\n    abortedFlags.set(signal, false)\n    return signal\n}\n\n/**\n * Abort a given signal.\n * @param {AbortSignal} signal The signal to abort.\n * @returns {void}\n */\nexport function abortSignal(signal) {\n    if (abortedFlags.get(signal) !== false) {\n        return\n    }\n\n    abortedFlags.set(signal, true)\n    signal.dispatchEvent({ type: \"abort\" })\n}\n","import AbortSignal, { abortSignal, createAbortSignal } from \"./abort-signal.mjs\"\n\n/**\n * Associated signals.\n * @type {WeakMap<AbortController, AbortSignal>}\n */\nconst signals = new WeakMap()\n\n/**\n * Get the associated signal of a given controller.\n * @param {AbortController} controller The controller to get its associated signal.\n * @returns {AbortSignal} The associated signal.\n */\nfunction getSignal(controller) {\n    const signal = signals.get(controller)\n    if (signal == null) {\n        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? \"null\" : typeof controller}`)\n    }\n    return signal\n}\n\n/**\n * The AbortController.\n * @constructor\n * @name AbortController\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */\nexport default class AbortController {\n    constructor() {\n        signals.set(this, createAbortSignal())\n    }\n\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     * @type {AbortSignal}\n     */\n    get signal() {\n        return getSignal(this)\n    }\n\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     * @returns {void}\n     */\n    abort() {\n        // Not depend on this.signal which is overridable.\n        const signal = getSignal(this)\n        if (signal != null) {\n            abortSignal(signal)\n        }\n    }\n}\n\n// Properties should be enumerable.\nObject.defineProperties(AbortController.prototype, {\n    signal: {\n        enumerable: true\n    },\n    abort: {\n        enumerable: true\n    },\n})\n\nexport { AbortController, AbortSignal }\n"],"names":["retv","privateData","get","assert","set","event","timeStamp","Date","now","defineProperty","value","enumerable","keys","Object","i","length","key","defineRedirectDescriptor","pd","apply","arguments","call","prototype","create","BaseEvent","configurable","writable","descriptor","getOwnPropertyDescriptor","isFunc","CustomEvent","defineCallDescriptor","proto","wrapper","wrappers","defineWrapper","getWrapper","getPrototypeOf","Wrapper","stopped","eventPhase","currentTarget","passiveListener","x","listeners","listenersMap","TypeError","getListeners","node","listenerType","listener","next","isObject","prev","delete","newNode","defineEventAttributeDescriptor","EventTarget","eventNames","CustomEventTarget","Map","Array","isArray","defineCustomEventTarget","types","signal","AbortSignal","abortedFlags","dispatchEvent","type","signals","controller","WeakMap","Event","target","eventTarget","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","data","stopPropagation","stopImmediatePropagation","bubbles","cancelable","canceled","preventDefault","warn","defaultPrevented","composed","window","setPrototypeOf","CAPTURE","BUBBLE","ATTRIBUTE","optionsIsObj","capture","options","passive","once","eventName","wrappedEvent","wrapEvent","handleEvent","isStopped","aborted","defineProperties","defineEventAttribute","AbortController","createAbortSignal","getSignal"],"mappings":";;;;0MAsCA,aAAmB,IACTA,GAAOC,EAAYC,GAAZD,mBACLE,OAAe,IAARH,IAAc,qDAcjC,eAAmC,GACnBI,IAAI,KAAM,cAAA,QAAA,YAGN,CAHM,gBAAA,YAAA,WAAA,iBAOD,IAPC,WAQPC,EAAMC,SAAND,EAAmBE,KAAKC,GAALD,EARZ,EADS,QAaxBE,eAAe,KAAM,YAAa,CAAEC,QAAF,CAAgBC,aAAhB,EAbV,WAgBzBC,EAAOC,OAAOD,IAAPC,IACJC,EAAI,EAAGA,EAAIF,EAAKG,OAAQ,MACjBH,KACNI,IAAO,cACFP,eAAe,OAAWQ,MAwL7C,aAAuC,OAC5B,eACG,OACKC,GAAG,IAAHA,EAASb,KAATa,GAFR,CAAA,gBAIQ,GACJ,MAAMb,UALV,CAAA,gBAAA,cAAA,EAkBX,aAAmC,OACxB,iBACK,IACEA,GAAQa,EAAG,IAAHA,EAASb,YAChBA,MAAWc,KAAXd,GAAwBe,SAAxBf,CAHR,CAAA,gBAAA,cAAA,EAiBX,eAAyC,gBAOI,GAC3BgB,KAAK,aAPbT,GAAOC,OAAOD,IAAPC,OACO,CAAhBD,KAAKG,kBASGO,UAAYT,OAAOU,MAAPV,CAAcW,EAAUF,SAAxBT,CAAmC,aAC1C,CAAEH,OAAF,CAAsBe,eAAtB,CAA0CC,WAA1C,CAD0C,CAAnCb,CAXa,KAgBhC,MAAIC,EAAI,EAAGA,EAAIF,EAAKG,OAAQ,SACjBH,KACR,EAAEI,IAAOQ,GAAUF,SAAnB,EAA+B,IACzBK,GAAad,OAAOe,wBAAPf,MACbgB,EAAsC,UAA5B,QAAOF,GAAWjB,aAC3BD,eACHqB,EAAYR,YAEZO,EAASE,IAATF,CAAqCZ,eAcrD,aAA2B,IACV,IAATe,KAAiBA,IAAUnB,OAAOS,sBAIlCW,GAAUC,EAAShC,GAATgC,UACC,KAAXD,QACUE,EAAcC,EAAWvB,OAAOwB,cAAPxB,GAAXuB,CAAdD,MACD/B,YAYjB,eAAuC,IAC7BkC,GAAUF,EAAWvB,OAAOwB,cAAPxB,GAAXuB,QACT,YASX,aAA0B,OACflB,MAAUqB,QAUrB,eAA0C,MAC5BC,aAUd,eAAgD,MAClCC,gBAUd,eAAoD,MACtCC,kBA6Bd,aAAqB,OACJ,KAANC,MAA2B,QAAb,0CAAA,EASzB,aAAmC,IACzBC,GAAYC,EAAa3C,GAAb2C,OACD,IAAbD,SACM,IAAIE,UAAJ,CAAc,oEAAd,WAWd,aAAmD,OACxC,eACG,QACIF,GAAYG,EAAa,IAAbA,EACdC,EAAOJ,EAAU1C,GAAV0C,GAFT,CAGa,IAARI,GAHL,EAGmB,IACbA,EAAKC,YAALD,WACOA,GAAKE,WAETF,EAAKG,WAET,KAVR,CAAA,gBAaW,CACc,UAApB,YAAmCC,IAD7B,KAEK,IAFL,SAIJR,GAAYG,EAAa,IAAbA,EAGdM,EAAO,KACPL,EAAOJ,EAAU1C,GAAV0C,GARD,CASK,IAARI,GATG,EAUFA,EAAKC,YAALD,IAVE,CAYW,IAATK,GAZF,CAeqB,IAAdL,KAAKG,IAfZ,GAmBYG,SAnBZ,GAgBYlD,MAAe4C,EAAKG,KAhBhC,GAaOA,KAAOH,EAAKG,IAbnB,IAAA,GA0BCH,EAAKG,IA1BN,IA8BO,IAAbD,KAAmB,IACbK,GAAU,WAAA,eAAA,WAAA,QAAA,MAKN,IALM,EAOH,IAATF,IARe,GASLjD,QATK,GAYV+C,OAvDd,CAAA,gBAAA,cAAA,EAsEX,eAA+D,QACpD1C,wBAAuD+C,MASlE,aAA6C,aAEZ,GACbnC,KAAK,QAGHC,UAAYT,OAAOU,MAAPV,CAAc4C,EAAYnC,SAA1BT,CAAqC,aAClD,CAAEH,OAAF,CAA4Be,eAA5B,CAAgDC,WAAhD,CADkD,CAArCb,CANW,KAUpC,GAAIC,GAAI,EAAGA,EAAI4C,EAAW3C,OAAQ,MACd4C,EAAkBrC,UAAWoC,eAmB1D,YAAuB,IAEf,gCACatD,IAAI,KAAM,GAAIwD,SAGN,CAArBxC,aAAUL,MAAVK,EAA0ByC,MAAMC,OAAND,CAAczC,UAAU,CAAVA,CAAdyC,QACnBE,GAAwB3C,UAAU,CAAVA,CAAxB2C,KAEY,CAAnB3C,WAAUL,OAAY,QAChBiD,GAAYH,KAAZG,CAAkB5C,UAAUL,MAA5BiD,EACGlD,EAAI,EAAGA,EAAIM,UAAUL,OAAQ,SACvBK,mBAER2C,WAEL,IAAIjB,UAAJ,CAAc,mCAAd,kkBCxgBV,YAAoC,IAC1BmB,GAASpD,OAAOU,MAAPV,CAAcqD,EAAY5C,SAA1BT,WACHQ,UACCjB,YASjB,aAAoC,CAC5B+D,OAAajE,GAAbiE,GAD4B,KAKnB/D,SALmB,GAMzBgE,cAAc,CAAEC,KAAM,OAAR,EANW,gGCzDpC,aAA+B,IACrBJ,GAASK,EAAQpE,GAARoE,OACD,IAAVL,SACM,IAAInB,UAAJ,oEAA2F,IAAfyB,KAAsB,MAAtBA,wCAA5E,2NFORtE,EAAc,GAAIuE,SAOlBtC,EAAW,GAAIsC,SAkDrBC,EAAMnD,SAANmD,CAAkB,IAKVJ,OAAO,OACAnD,GAAG,IAAHA,EAASb,KAATa,CAAemD,IANZ,CAAA,IAaVK,SAAS,OACFxD,GAAG,IAAHA,EAASyD,WAdN,CAAA,IAqBVlC,gBAAgB,OACTvB,GAAG,IAAHA,EAASuB,aAtBN,CAAA,wBA4BC,IACLA,GAAgBvB,EAAG,IAAHA,EAASuB,cADpB,MAEU,KAAjBA,GAFO,IAKJ,GAjCG,CAAA,IAwCVmC,OAAO,OACA,EAzCG,CAAA,IAgDVC,kBAAkB,OACX,EAjDG,CAAA,IAwDVC,YAAY,OACL,EAzDG,CAAA,IAgEVC,iBAAiB,OACV,EAjEG,CAAA,IAwEVvC,aAAa,OACNtB,GAAG,IAAHA,EAASsB,UAzEN,CAAA,2BAgFI,IACRwC,GAAO9D,EAAG,IAAHA,EAC6B,UAAtC,QAAO8D,GAAK3E,KAAL2E,CAAWC,eAFR,IAGL5E,MAAM4E,iBAnFL,CAAA,oCA2Fa,IACjBD,GAAO9D,EAAG,IAAHA,IAERqB,UAHkB,CAI4B,UAA/C,QAAOyC,GAAK3E,KAAL2E,CAAWE,wBAJC,IAKd7E,MAAM6E,0BAhGL,CAAA,IAwGVC,UAAU,SACKjE,EAAG,IAAHA,EAASb,KAATa,CAAeiE,OAzGpB,CAAA,IAgHVC,aAAa,SACElE,EAAG,IAAHA,EAASb,KAATa,CAAekE,UAjHpB,CAAA,0BAwHG,IACPJ,GAAO9D,EAAG,IAAHA,EADA,MAEe,KAAxB8D,IAAKtC,eAFI,MAMT,CAACsC,EAAK3E,KAAL2E,CAAWI,UANH,KAURC,WAVQ,CAW4B,UAArC,QAAOL,GAAK3E,KAAL2E,CAAWM,cAXT,IAYJjF,MAAMiF,gBAZF,gBAGDC,KAAK,6DAA8DP,EAAKtC,gBA3H1E,CAAA,IA4IV8C,mBAAmB,OACZtE,GAAG,IAAHA,EAASmE,QA7IN,CAAA,IAoJVI,WAAW,SACIvE,EAAG,IAAHA,EAASb,KAATa,CAAeuE,QArJpB,CAAA,IA4JVnF,YAAY,OACLY,GAAG,IAAHA,EAASZ,UA7JN,EAkKlBO,OAAOJ,cAAPI,CAAsB4D,EAAMnD,SAA5BT,CAAuC,aAAvCA,CAAsD,CAAEH,OAAF,CAAgBe,eAAhB,CAAoCC,WAApC,CAAtDb,EAGsB,WAAlB,QAAO6E,OAAP,EAAyD,WAAxB,QAAOA,QAAOjB,eACxCkB,eAAelB,EAAMnD,UAAWoE,OAAOjB,KAAPiB,CAAapE,aAG3ClB,IAAIsF,OAAOjB,KAAPiB,CAAapE,cAsK9B,GAAMuB,GAAe,GAAI2B,QAAzB,CAGMoB,EAAU,CAHhB,CAIMC,EAAS,CAJf,CAKMC,EAAY,CALlB,CAwKArC,EAAYnC,SAAZmC,CAAwB,iCAQ2B,IAC3B,IAAZP,gBAGoB,UAApB,YAAkC,CAACE,UAC7B,IAAIN,UAAJ,CAAc,iDAAd,KAGJF,GAAYG,EAAa,IAAbA,EACZgD,EAAe3C,KACf4C,EAAUD,IAAuBE,EAAQD,OAA/BD,KACV9C,EAAgB+C,MAChBzC,EAAU,WAAA,eAAA,SAGHwC,KAAwBE,EAAQC,OAH7B,MAINH,KAAwBE,EAAQE,IAJ1B,MAKN,IALM,EASZnD,EAAOJ,EAAU1C,GAAV0C,OACPI,oBACU5C,YAvB6B,OA4BvCiD,GAAO,IA5BgC,CA6B5B,IAARL,GA7BoC,EA6BtB,IACbA,EAAKE,QAALF,MAA8BA,EAAKC,YAALD,iBADjB,GAMVA,EAAKG,cAIXA,SA/CW,CAAA,oCA0D8B,IAC9B,IAAZD,aAD0C,OAKxCN,GAAYG,EAAa,IAAbA,EACZiD,EAAU5C,OAA4B6C,EAAQD,OAApC5C,KACVH,EAAgB+C,MAElB3C,EAAO,KACPL,EAAOJ,EAAU1C,GAAV0C,GAVmC,CAW/B,IAARI,GAXuC,EAWzB,IACbA,EAAKE,QAALF,MAA8BA,EAAKC,YAALD,WACjB,KAATK,IAGmB,IAAdL,KAAKG,OAIAG,YAHAlD,MAAe4C,EAAKG,QAHzBA,KAAOH,EAAKG,WAHR,GAeVH,EAAKG,aApFA,CAAA,0BA+FC,IACJ,IAAT9C,KAAuC,QAAtB,QAAOA,GAAMgE,UACxB,IAAIvB,UAAJ,CAAc,kCAAd,KAIJF,GAAYG,EAAa,IAAbA,EACZqD,EAAY/F,EAAMgE,KACpBrB,EAAOJ,EAAU1C,GAAV0C,OACC,IAARI,aATa,OAcXqD,GAAeC,EAAU,IAAVA,IAIjBjD,EAAO,IAlBM,CAmBF,IAARL,GAnBU,GAqBTA,EAAKmD,IArBI,CAsBI,IAAT9C,GAtBK,CAyBc,IAAdL,KAAKG,IAzBL,GA6BKG,SA7BL,GA0BKlD,MAAe4C,EAAKG,KA1BzB,GAuBAA,KAAOH,EAAKG,IAvBZ,IAAA,KAqCqBH,EAAKkD,OAALlD,CAAeA,EAAKE,QAApBF,CAA+B,KArCpD,CAsCgB,UAAzB,QAAOA,GAAKE,QAtCH,GAuCJA,SAAS7B,KAAK,OAvCV,CAyCJ2B,EAAKC,YAALD,MAAwE,UAArC,QAAOA,GAAKE,QAALF,CAAcuD,WAzCpD,IA0CJrD,SAASqD,cA1CL,EA8CTC,IA9CS,KAkDNxD,EAAKG,IAlDC,YAoDgB,UACL,OACG,MAExB,CAACkD,EAAab,iBAvJL,EA4JxB3E,OAAOJ,cAAPI,CAAsB4C,EAAYnC,SAAlCT,CAA6C,aAA7CA,CAA4D,CAAEH,OAAF,CAAsBe,eAAtB,CAA0CC,WAA1C,CAA5Db,EAGsB,WAAlB,QAAO6E,OAAP,EAA+D,WAA9B,QAAOA,QAAOjC,oBACxCkC,eAAelC,EAAYnC,UAAWoE,OAAOjC,WAAPiC,CAAmBpE,4cCjuB9D6C,EAAe,GAAIK,SAQJN,0BACH,iBACJ,GAAIpB,UAAJ,CAAc,4CAAd,kDAYI,IACJ2D,GAAUtC,EAAajE,GAAbiE,CAAiB,IAAjBA,KACO,SAAnB,gBACM,IAAIrB,UAAJ,gEAAiF,IAAT,QAAgB,MAAhB,GAAgC,MAAxG,sBAclBjC,OACO6F,gBADP,CACwBxC,EAAY5C,SADpC,CAC+C,SAClC,cAAA,CADkC,CAD/C,EAOAqF,EAAqBzC,EAAY5C,SAAjCqF,CAA4C,OAA5CA,mcC9CMrC,EAAU,GAAIE,SAqBCoC,yBACH,UAAA,GACFxG,IAAI,KAAMyG,8CAed,IAEE5C,GAAS6C,EAAU,IAAVA,EACD,IAAV7C,GAHA,qCARK,OACF6C,GAAU,IAAVA,cAgBfjG,OACO6F,gBADP,CACwBE,EAAgBtF,SADxC,CACmD,QACvC,cAAA,CADuC,OAIxC,cAAA,CAJwC,CADnD"}